diff --git a/cogs/DetermineServerBuild.py b/cogs/DetermineServerBuild.py
new file mode 100644
index 0000000..5ba04a4
--- /dev/null
+++ b/cogs/DetermineServerBuild.py
@@ -0,0 +1,128 @@
+# pylint: disable=invalid-name,line-too-long,missing-function-docstring
+"""
+    This module is intended to figure out if the dedicated server needs updating.
+"""
+
+import os
+import ntpath
+import feedparser
+
+
+class DetermineServerBuild():
+    """
+        Parse build version data from SteamDB RSS, and check against
+        appmanifest_728470.acf for the purposes of updating.
+    """
+
+    def __init__(self, astroPath):
+        """
+            Get version numbers to check against
+        """
+        self.acfPath = ntpath.realpath(os.getcwd() + '/steamcmd/steamapps/appmanifest_728470.acf')
+        if astroPath is not None:
+            self.acfPath = ntpath.realpath(astroPath + '/steamcmd/steamapps/appmanifest_728470.acf')
+        self.buildACF = self.getBuildIDFromACF()
+        self.buildRSS = self.getBuildsFromRSS()
+
+    def getBuildsFromRSS(self):
+        """
+            Get a sorted version list from SteamDB RSS feed
+        """
+        try:
+            rssData = feedparser.parse('https://steamdb.info/api/PatchnotesRSS/?appid=728470')
+            buildList = []
+            for n in rssData.entries:
+                # truncate "SteamDB Build "
+                if hasattr(n, 'description') and isinstance(n.description, str):
+                    buildNumber = int(n.description[14:])
+                    buildList.append(buildNumber)
+            buildList.sort(reverse=True)
+            return buildList
+        except (ValueError, KeyError, AttributeError, IndexError, TypeError):
+            # Return empty list if RSS parsing fails
+            return []
+
+    def getCurrentBuildID(self):
+        """
+            Grab current build ID from ACF
+        """
+        return self.buildACF
+
+    def getLatestBuildID(self):
+        """
+            Grab latest version from pre-sorted list
+        """
+        if not self.buildRSS:
+            return 0
+        return self.buildRSS[0]
+
+    def getBuildIDFromACF(self):
+        """
+            Get the current version number from the Steam ACF
+        """
+        version = 0
+        if ntpath.exists(self.acfPath):
+            try:
+                manifestData = self.parse_manifest_kv(self.acfPath)
+                build_id = manifestData.get('TargetBuildID')
+                if build_id:
+                    version = int(build_id)
+            except (OSError, ValueError, KeyError):
+                # Return 0 if file can't be read or parsed
+                pass
+        return version
+
+    def updateOK(self):
+        """
+            Determine if an update is needed
+        """
+        self.buildACF = self.getBuildIDFromACF()
+        self.buildRSS = self.getBuildsFromRSS()
+        if self.buildACF > 0 and self.buildRSS is not None:
+            return self.buildACF < self.buildRSS[0]
+        return False
+
+    # ACF parser generated by Claude.AI
+    def parse_manifest_kv(self, file_path):
+        """
+            Parse Steam app manifest file into key-value pairs
+        """
+        kv_dict = {}
+        stack = [kv_dict]  # Stack to handle nested sections
+
+        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
+            for line in f:
+                line = line.strip()
+
+                # Skip empty lines and comments
+                if not line or line.startswith('//'):
+                    continue
+
+                # Handle opening brace (start of section)
+                if line == '{':
+                    continue
+
+                # Handle closing brace (end of section)
+                if line == '}':
+                    if len(stack) > 1:
+                        stack.pop()
+                    continue
+
+                # Parse key-value pairs
+                parts = line.split(None, 1)  # Split on first whitespace
+                if len(parts) == 2:
+                    key, value = parts
+                    key = key.strip('"')
+                    value = value.strip('"')
+
+                    # Check if value is a section (next line is {)
+                    if value == '':
+                        # This is a section header
+                        new_section = {}
+                        stack[-1][key] = new_section
+                        stack.append(new_section)
+                    else:
+                        # This is a key-value pair
+                        stack[-1][key] = value
+
+        return kv_dict
diff --git a/AstroLauncher.py b/AstroLauncher.py
index 4b98b42..3c8e452 100644
--- a/AstroLauncher.py
+++ b/AstroLauncher.py
@@ -31,6 +31,7 @@ from cogs.AstroDedicatedServer import AstroDedicatedServer
 from cogs.AstroLogging import AstroLogging
 from cogs.MultiConfig import MultiConfig
 from cogs.utils import AstroRequests
+from cogs.DetermineServerBuild import DetermineServerBuild
 
 from cogs.utils import ALVERSION
 
@@ -530,66 +531,42 @@ class AstroLauncher():
         try:
             # print('here1')
             if not self.launcherConfig.UpdateOnServerRestart and serverStart:
-                return
-            else:
-                # print('here2')
-                needs_update = False
-                update_status = None
-                if ntpath.exists("update.p"):
-                    with open("update.p", "r") as f:
-                        update_status = f.read()
-                    if update_status != "completed":
-                        needs_update = True
-
-                # print('here3')
-                cur_version = "0.0"
-                try:
-                    with open(ntpath.join(self.astroPath, "build.version"), "r") as f:
-                        cur_version = (f.readline())[:-10]
-                except:
-                    pass
-                # print(cur_version)
-                # print('here4')
-                if cur_version == "0.0":
+                return False, "0.0"
+            # print('here2')
+            needs_update = False
+            update_status = None
+            if ntpath.exists("update.p"):
+                with open("update.p", "r") as f:
+                    update_status = f.read()
+                if update_status != "completed":
                     needs_update = True
-                url = "https://astroservercheck.joejoetv.de/api/stats"
-                try:
-                    data = json.load(AstroRequests.get(url))
-                    # print(data)
-
-                    # print('here6')
-                    latest_version = data['stats']['latestVersion']
-                    if version.parse(latest_version) > version.parse(cur_version):
-                        needs_update = True
-                    if not ntpath.exists(ntpath.join(self.astroPath, "AstroServer.exe")):
-                        needs_update = True
-                    if needs_update:
-                        AstroLogging.logPrint(
-                            f"SERVER UPDATE AVAILABLE: {cur_version} -> {latest_version}", "warning")
-
-                        # print('here7')
-                        if self.launcherConfig.AutoUpdateServerSoftware and not check_only:
-                            self.update_server(latest_version)
-                        # print('here8')
-                        return True, latest_version
-                except Exception as e:
-                    print(e)
-                    AstroLogging.logPrint(
-                        "Couldn't get latest version number!", "warning")
-                    
-                    if self.launcherConfig.AutoUpdateServerSoftware and not check_only:
-                        self.update_server("unknown")
-                    
+
+            # print('here3')
+            cur_version = "0.0"
+            try:
+                with open(ntpath.join(self.astroPath, "build.version"), "r") as f:
+                    cur_version = (f.readline())[:-10]
+            except:
+                pass
+
+            # Use new update determination
+            AstroLogging.logPrint(
+                    " Checking for AstroServer update", "info")
+            dbv = DetermineServerBuild(self.astroPath)
+            needs_update = dbv.updateOK()
+
+            if not ntpath.exists(ntpath.join(self.astroPath, "AstroServer.exe")):
+                needs_update = True
+            if needs_update:
+                AstroLogging.logPrint(
+                    f"SERVER UPDATE AVAILABLE: {dbv.getCurrentBuildID()} -> {dbv.getLatestBuildID()}", "warning")
+                if self.launcherConfig.AutoUpdateServerSoftware and not check_only:
+                    self.update_server(dbv.getLatestBuildID())
                     with open(ntpath.join(self.astroPath, "build.version"), "r") as f:
                         cur_version = (f.readline())[:-10]
-                    
-                    return True, cur_version
+                        self.cur_server_version = cur_version
+                return True, cur_version
 
-            cur_version = "0.0"
-            with open(ntpath.join(self.astroPath, "build.version"), "r") as f:
-                cur_version = (f.readline())[:-10]
-            self.cur_server_version = cur_version
-            # print('here9')
         except Exception as e:
             print(e)
             AstroLogging.logPrint(
