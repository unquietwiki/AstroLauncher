# pylint: disable=invalid-name,line-too-long,missing-function-docstring
"""
    This module is intended to figure out if the dedicated server needs updating.
"""

import os
import ntpath
import feedparser


class DetermineServerBuild():
    """
        Parse build version data from SteamDB RSS, and check against
        appmanifest_728470.acf for the purposes of updating.
    """

    def __init__(self, astroPath):
        """
            Get version numbers to check against
        """
        self.acfPath = ntpath.realpath(os.getcwd() + '/steamcmd/steamapps/appmanifest_728470.acf')
        if astroPath is not None:
            self.acfPath = ntpath.realpath(astroPath + '/steamcmd/steamapps/appmanifest_728470.acf')
        self.buildACF = self.getBuildIDFromACF()
        self.buildRSS = self.getBuildsFromRSS()

    def getBuildsFromRSS(self):
        """
            Get a sorted version list from SteamDB RSS feed
        """
        try:
            rssData = feedparser.parse('https://steamdb.info/api/PatchnotesRSS/?appid=728470')
            buildList = []
            for n in rssData.entries:
                # truncate "SteamDB Build "
                if hasattr(n, 'description') and isinstance(n.description, str):
                    buildNumber = int(n.description[14:])
                    buildList.append(buildNumber)
            buildList.sort(reverse=True)
            return buildList
        except (ValueError, KeyError, AttributeError, IndexError, TypeError):
            # Return empty list if RSS parsing fails
            return []

    def getCurrentBuildID(self):
        """
            Grab current build ID from ACF
        """
        return self.buildACF

    def getLatestBuildID(self):
        """
            Grab latest version from pre-sorted list
        """
        if not self.buildRSS:
            return 0
        return self.buildRSS[0]

    def getBuildIDFromACF(self):
        """
            Get the current version number from the Steam ACF
        """
        version = 0
        if ntpath.exists(self.acfPath):
            try:
                manifestData = self.parse_manifest_kv(self.acfPath)
                build_id = manifestData.get('TargetBuildID')
                if build_id:
                    version = int(build_id)
            except (OSError, ValueError, KeyError):
                # Return 0 if file can't be read or parsed
                pass
        return version

    def updateOK(self):
        """
            Determine if an update is needed
        """
        self.buildACF = self.getBuildIDFromACF()
        self.buildRSS = self.getBuildsFromRSS()
        if self.buildACF > 0 and self.buildRSS is not None:
            return self.buildACF < self.buildRSS[0]
        return False

    # ACF parser generated by Claude.AI
    def parse_manifest_kv(self, file_path):
        """
            Parse Steam app manifest file into key-value pairs
        """
        kv_dict = {}
        stack = [kv_dict]  # Stack to handle nested sections

        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            for line in f:
                line = line.strip()

                # Skip empty lines and comments
                if not line or line.startswith('//'):
                    continue

                # Handle opening brace (start of section)
                if line == '{':
                    continue

                # Handle closing brace (end of section)
                if line == '}':
                    if len(stack) > 1:
                        stack.pop()
                    continue

                # Parse key-value pairs
                parts = line.split(None, 1)  # Split on first whitespace
                if len(parts) == 2:
                    key, value = parts
                    key = key.strip('"')
                    value = value.strip('"')

                    # Check if value is a section (next line is {)
                    if value == '':
                        # This is a section header
                        new_section = {}
                        stack[-1][key] = new_section
                        stack.append(new_section)
                    else:
                        # This is a key-value pair
                        stack[-1][key] = value

        return kv_dict
